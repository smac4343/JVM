# JVM
JVM. Организация памяти, сборщики мусора, VisualVM


Класс JvmComprehension загружается в память с помощью системного ClassLoader. Поскольку это класс верхнего уровня, его не требуется загружать динамически.

Метод main() вызывается, и новый фрейм создается на стеке вызовов. Это делается для каждого вызова метода.

Во фрейме создается новая примитивная переменная i со значением 1. Это значение хранится на стеке, так как это локальная переменная для метода main().

Объект Object o создается в куче (heap), и ссылка на этот объект хранится в стеке вызовов в фрейме метода main().

Переменная ii создается в куче (heap), так как это объект-оболочка Integer. Ссылка на этот объект также хранится на стеке вызовов.

Метод printAll() вызывается с аргументами o, i и ii. Новый фрейм создается для этого метода на стеке вызовов.

В этом фрейме создается новая переменная uselessVar со значением 700. Она создается в куче (heap), так как это объект Integer. Ссылка на этот объект хранится в стеке вызовов в фрейме метода printAll().

Метод println() вызывается для печати значений o, i и ii.

После выполнения метода printAll(), его фрейм удаляется из стека вызовов, а переменная uselessVar становится доступной для сборки мусора, так как на нее больше нет активных ссылок.

В конце метода main(), выполняется System.out.println("finished").

После завершения метода main(), его фрейм удаляется из стека вызовов, и все локальные переменные (в данном случае o, i и ii) становятся доступными для сборки мусора, так как на них больше нет активных ссылок.

После того как программа завершает выполнение, JVM заканчивает работу, освобождая все использованные ресурсы.